---
title: LeetCode Summary
date: 2025-09-01
permalink: /posts/2025/09/blog-post-1/
tags:
---

### 哈希表的基本运用
**给定一个整数数组和一个整数目标值，请在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。**
方法1 暴力循环求解，时间复杂度为O（n^2）
方法2 哈希表
先上代码
```Cpp
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
    return {};
    }
```
哈希表
基本原理：通过哈希函数，将多维关键字映射到低维数组空间内，然后根据关键字直接确定查找值所在位置，而不需要一个个比较搜索
那哈希表从本质上是如何做到的呢？直接将key值代入哈希函数求得查找值！
理论上，输出值个数=输入值个数，若输出值个数>输入值个数不会产生恶性影响，只需要避免哈希冲突即可。

**闭散列**
闭散列，也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个”空位置中去。闭散列中主要处理方法有线性探测和二次探测。

线性探测思想：从计算的哈希位置开始，往后找到第一个空闲的位置存放数据

二次探测和线性探测都属于闭散列，其原理都一样，两者的主要区别就是探测的方式不同，线性探测是如果要插入的位置已有元素，会一个一个往后查找到新的空位置。而二次探测是通过该位置的哈希冲突次数的平方来向后查找新的位置

**开散列**
开散列方法又叫链地址法，哈希表中存储的是链表的头结点。具有相同的哈希地址会存放在同一链表中，每个链表中的元素都具有相同的哈希地址。

闭散列-线性探测

```C
enum STATE
{
 EXIST,
 DELETE,
 EMPTY
};
//哈希表：线性探测解决哈希冲突
template<class K, class V>
struct HashNode
{
 pair<K, V> _kv;//数据
	STATE _state = EMPTY;//状态
};

//顺序表实现哈希
template<class K, class V>
class HashTable
{
public:
 typedef HashNode<K, V> Node;

	HashTable(size_t n = 10)
		:_hTable(n)
		,_size(0)
	{}

	bool insert(const pair<K, V>& kv)
	{
		//0.检查容量
		checkCapacity();

		//1.当前元素的哈希位置
		int idx = kv.first % _hTable.size();

		//2.判断key是否存在
		while (_hTable[idx]._state != EMPTY)//当前位置已有数据或者为删除位置，都不能存放
		{
			//当前位置存在数据且key相同，则不能插入
			if (_hTable[idx]._state == EXIST
				&& _hTable[idx]._kv.first == kv.first)
			{
				return false;
			}
			//继续往后搜索空位置
			++idx;
			//走到末尾，需要从头开始找
			if (idx == _hTable.size())
				idx = 0;
		}

		_hTable[idx]._kv = kv;
		_hTable[idx]._state = EXIST;
		++_size;
		
		return true;
	}

	void checkCapacity()
	{
		//负载因子[0, 1],这里定负载因子为0.7
		if (_hTable.size() == 0 || _size * 10 / _hTable.size() >= 7)
		{
			//创建新表
			int newC = _hTable.size() == 0 ? 10 : 2 * _hTable.size();
			HashTable<K, V> newHt(newC);

			for (size_t i = 0; i < _hTable.size(); ++i)
			{
				//将原先的表的数据插入到新的表中，
				if (_hTable[i]._state == EXIST)
				{
					newHt.insert(_hTable[i]._kv);
				}
			}
			//交换两个表的内容
			Swap(newHt);
		}
	}

	void Swap(HashTable<K, V>& Ht)
	{
		swap(_hTable, Ht._hTable);
		swap(_size, Ht._size);
	}

	Node* find(const K& key)
	{
		//计算位置
		int idx = key % _hTable.size();
		while (_hTable[idx]._state != EMPTY)
		{
			//找到
			if (_hTable[idx]._state == EXIST
				&& key == _hTable[idx]._kv.first)
			{
				return &_hTable[idx];
			}
			++idx;
			if (idx == _hTable.size())
				idx = 0;
		}
		//如果遇到空格则表示没找到，返回空
		return nullptr;
	}

	bool erase(const K& key)
	{
		Node* node = find(key);
		if (node)
		{
			//伪删除
			--_size;
			node->_state = DELETE;
			return true;
		}
		return false;
	}
private:
	vector<Node> _hTable;//表
	size_t _size;//有效元素个数
};

```
开散列

```C
#include <vector>
#include <iostream>
using namespace std;

template<class K>
struct HashNode
{
	typedef HashNode<K> Node;
	K _val;
	Node* _next;

	HashNode(const K& val)
		:_val(val)
		, _next(nullptr)
	{}
};

template<class K>
class HTable
{
public:
	typedef HashNode<K> Node;

	HTable(int n = 10)
		:_ht(n)
		, _size(0)
	{}

	bool insert(const K& val)
	{
		//0.检查容量
		checkCapacity();

		//1.计算hash位置
		int idx = val % _ht.size();

		//2.查找
		Node* cur = _ht[idx];
		while (cur)
		{
			if (cur->_val == val)
				return false;
			cur = cur->_next;
		}

		//3.插入--头插
		cur = new Node(val);
		cur->_next = _ht[idx];
		_ht[idx] = cur;
		++_size;
		return true;
	}

	void checkCapacity()
	{
		if (_size == _ht.size())
		{
			int newC = _size == 0 ? 10 : 2 * _size;

			//创建新的指针数组
			vector<Node*> newHt(newC);

			//遍历旧表
			for (size_t i = 0; i < _ht.size(); ++i)
			{
				Node* cur = _ht[i];
				//遍历单链表
				while (cur)
				{
					Node* next = cur->_next;
					//计算新的位置
					int idx = cur->_val % newHt.size();
					//头插
					cur->_next = newHt[idx];
					newHt[idx] = cur;

					cur = next;
				}
				//旧表指针置空
				_ht[i] = nullptr;
			}

			//交换新表和旧表
			swap(_ht, newHt);
		}
	}

	Node* find(const K& val)
	{
		int idx = val % _ht.size();
		Node* cur = _ht[idx];
		while (cur)
		{
			if (cur->_val == val)
				return cur;
			cur = cur->_next;
		}
		return nullptr;
	}

	bool erase(const K& val)
	{
		Node* node = find(val);
		if (node)
		{
			int idx = val % _ht.size();
			Node* cur = _ht[idx];
			Node* prev = nullptr;
			while (cur != node)
			{
				prev = cur;
				cur = cur->_next;
			}
			Node* next = cur->_next;
			if (prev)
				prev->_next = next;
			else
				_ht[idx] = next;
			--_size;
			delete node;
			return true;
		}
		return false;
	}
private:
	//指针数组
	vector<Node*> _ht;
	int _size;
};

```
参考博客：
https://blog.csdn.net/qq_44443986/article/details/117195803

拓展：二叉树算法

<div STYLE="page-break-after: always;"></div>

### 链表问题
**题目简述：**两个非空链表，表示两个非负整数。它们每位数字都是按照 _逆序_ 的方式存储，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。假设除了0之外，两个数都不会以0开头( 没做出来！)

1.链表数据结构的成员：
node->next 代表　取这个节点的指针域的内容，这样就得到了下一个节点所在的内存地址
node->data 代表　取这个节点的数据域的内容

2.链表初始化
C++ nullptr
在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。0和NULL都是整形0
nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。
参考：http://c.biancheng.net/view/7887.html

链表中对地址的操作是重点，如何遍历一个链表
```C++
        //l1的val只表示当前节点吗?
        int sum=0;
        int i=0;
        ListNode* node=new ListNode;//创建的新链表的对象val和next值是多少？
        while(l1!=nullptr||l2!=nullptr){ //
            if(l1==nullptr){ 
                sum+=l2->val*int(pow(10,i));
                l2=l2->next; 
            }
            else if(l2==nullptr){ 
                sum+=l1->val*int(pow(10,i));
                // node->next=l1;
                l1=l1->next;
            }
            else{
                sum+=(l1->val+l2->val)*int(pow(10,i));//sum取余再除
                l1=l1->next;
                l2=l2->next; 
            }
            ListNode *nodeNext = new ListNode; //定义node的后继节点
            node->next = nodeNext;
            node=node->next;
            i++;
        }
    return node;
```
正确做法：
```	C
 ListNode *addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *l3 = new ListNode(-1); //定义新链表的头节点l3
        ListNode *node3 = l3; //定义头节点的副本node3
        int ex = 0; //定义一个进位值ex
        while (l1!= nullptr || l2!=nullptr){
            ListNode* nodeNext = new ListNode(-1); //定义node的后继节点 含义是创建val为-1的节点？
            node3->next = nodeNext;
            int a = 0;//将l1的val赋值给a
            if (l1 != nullptr){
                a = l1->val;
            }
            int b = 0;//将l2的val赋值给b
            if (l2 != nullptr){
                b = l2->val;
            }
            //将a和b的和赋值给c再加上进位值ex即为放入新链表的和
            int c = a + b + ex;
            //进行判断；若c >= 10 则产生进位值
            if (c >= 10){
                c =  c - 10;
                nodeNext->val = c;
                ex = 1;
            }else {
                nodeNext->val = c;
                ex = 0;
            }
            //以下各节点往后走一步
            node3 = node3->next;
            if (l1 != nullptr) {
                l1 = l1->next;}
            if (l2 != nullptr) {
                l2 = l2->next;}
        }
        //若循环走完仍然有进位值，则说明最后一位值位10，所以再新建一个尾巴节点值位1
        if (ex == 1){
            ListNode* cur = new ListNode(1);
            node3->next = cur;}
        return l3->next; //返回头节点的next域
    }
```

### 滑动窗口 
给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度。

bug的代码：没有使用滑动窗口，即非重复子序列之间可以**重叠**！
```C
int lengthOfLongestSubstring(string s) {//考察 动态数组
        vector<int> sub_len;
        int len=0;//每个子序列的序列号
        map<char,int> hashmap ;
        if(s.empty()){
            return {};
        }
        for (int i=0;i<s.size();i++){
            //hash表去判断有无重复-索引问题
            auto iter=hashmap.find(s[i]);//对于空map的做法
            if (iter!=hashmap.end()) { 
                hashmap.clear();//hash表清零
                sub_len.push_back(len);//如果没有重复字符的序列，则len为空数组
                len=0;//子序列长度清零
            }
            hashmap.insert(pair<char,int>(s[i],i));
            len++;
        }
        sub_len.push_back(len);
        if(sub_len.empty()){
            sub_len.push_back(s.size());}
        auto maxValue = max_element(sub_len.begin(),sub_len.end()); 
        return *maxValue;   
    }
//------------------------C++------------------------------	
int lengthOfLongestSubstring(string s) {
	// 哈希集合，记录每个字符是否出现过
	unordered_set<char> occ;
	int n = s.size();
	// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
	int rk = -1, ans = 0;
	// 枚举左指针的位置，初始值隐性地表示为 -1
	for (int i = 0; i < n; ++i) {
		if (i != 0) {
			// 左指针向右移动一格，移除一个字符
			occ.erase(s[i - 1]);
		}
		while (rk + 1 < n && !occ.count(s[rk + 1])) {
			// 不断地移动右指针
			occ.insert(s[rk + 1]);
			++rk;
		}
		// 第 i 到 rk 个字符是一个极长的无重复字符子串
		ans = max(ans, rk - i + 1);
	}
	return ans;}
```
### 找出并返回两个正序数组的中位数 。
算法的时间复杂度应该为 O(log (m+n)) 。
刷题的忌讳：使用高集成度的封装库函数
```C
    double mid=0;
    vector<double> num;//
    num.resize(nums1.size()+nums2.size());
    merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),num.begin());//不要直接merge
    int n=num.size();
    if(n%2==0){
        mid = (num[n/2-1]+num[n/2])/2;
    }
    else{
        mid=num[(n-1)/2];
    }
    return mid;
```
二分法：

### 最长回文子串。

循环之前清楚枚举的对象是什么！！

**M1：动态规划**
首先清楚回文串的自然条件：（1）空串（2）长度为1的串（3）两个相同字符的串，其中3可以后续判断
```C++
int n = s.size();
        if (n < 2) {
            return s;}
```
然后输出最长长度的回文串，即需要对每个回文串保存长度和内容两个值，最简单的方法是保存左右指针l和r。
回文串的首尾相同：
（1）比较每个子串的i和n-i是否相等，时间复杂度为O(n3)
（2）写出递推/状态转换公式：
$P(i,j)=P(i+1,j-1)^(S_i==S_j)$
P(i,j)能够递推到回文子串的中心。
（3）递推关系的边界条件
$P(i,i+1)=(S_i==S_{i+1}),P(i,i)=true$
*最终结果即为j-i+1的最大值*
```C
vector<vector<int>> dp(n, vector<int>(n));
// 初始化：所有长度为 1 的子串都是回文串
for (int i = 0; i < n; i++) {
	dp[i][i] = true;}
// 递推开始
// 先枚举子串长度，有助于递推关系进行
for (int L = 2; L <= n; L++) {
	// 枚举左边界，左边界的上限设置可以宽松一些
	for (int i = 0; i < n; i++) {
	// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
	int j = L + i - 1;
	// 如果右边界越界，就可以退出当前循环
	if (j >= n) {
		break;}
	if (s[i] != s[j]) {
		dp[i][j] = false;} 
	else {
		if (j - i < 3) {//边界条件，长度《=3
		dp[i][j] = true;}
		else {
		dp[i][j] = dp[i + 1][j - 1];
		}
	}
  }
}
```
最终动态规划代码简化后如下所示：
```C
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        int maxLen = 1;
        int begin =0;
        vector<int> dp(n);
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < j; i++) {
                dp[i] = (s[i]==s[j] ? (j-i<3 ? true : dp[i+1]) :false);
                if(dp[i] && (j-i+1)>maxLen){
                    maxLen =j-i+1;
                    begin =i;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
};
```
**中心扩展算法**
状态转移的可能性是唯一的，即每个递推链是互不相交的，因此可以从每一种边界情况出发，利用逆递推公式，遍历每个可能的子串
```C
pair<int, int> expandAroundCenter(const string& s, int left, int right) {
        while (left >= 0 && right < s.size() && s[left] == s[right]) {
            --left;
            ++right;
        }
        return {left + 1, right - 1};
    }

    string longestPalindrome(string s) {
        int start = 0, end = 0;
        for (int i = 0; i < s.size(); ++i) {
            auto [left1, right1] = expandAroundCenter(s, i, i);
            auto [left2, right2] = expandAroundCenter(s, i, i + 1);
            if (right1 - left1 > end - start) {
                start = left1;
                end = right1;
            }
            if (right2 - left2 > end - start) {
                start = left2;
                end = right2;
            }
        }
        return s.substr(start,end);
```

### Z字形变换 
**解题思路**
作者是通过周期类V图形块得到下标之间的映射关系来解决。但存在以下问题：
- 必须考虑末尾周期如果未填充满的情况
- 需要考虑到数组起始下标为0的情况
- 细节问题（如string初始化为空串后不能通过z[n]赋值）
  
而且算法题要避免纯数学思维，而是规律思维。
Z变换后的行字符串相加即为所求字符串；
按顺序遍历字符串s时，每个字符c在Z字形中对应的行索引先从1到numrows，再减小到1，flag表示方向。
```C
    if (numRows < 2) return s;              // 给定行数为 1 时结果与原字符串一样
    vector<string> res(numRows);            // 创建 res 保存每行结果
    int i = 0;                              // 行数标志
    int flag = -1;                          // 往上走还是往下走的标志
    for (char &ch : s) {                    // 遍历 s
        res[i] += ch;
        if (i == 0 || i == numRows - 1) {   // 行首行尾变向
            flag = -flag;
        }
        i += flag;                          
    }
    for (int i = 1; i < numRows; i++) {     // 将每行接起来就是结果
        res[0] += res[i];
    }
    return res[0];
```

### 整数反转
取整数各位置的方法：取模后递减（由低到高）或直接除以$10^{len-1}$（由高到低）
同时，本题要求：判断反转后的数是否溢出，且不能使用64位数，此时只能在计算出反转数前进行判断
明显，由高到低的提取，在9位的时候直接与"214748364"比较大小并比较10位的末位与7/-8即可
但在处理的过程中，如果用1+log10(x)求取整数位数时，直接用abs(x)有负边界的矛盾：即x不溢出，绝对值溢出
```C
// 弹出 x 的末尾数字 digit
digit = x % 10;x /= 10
// 将数字 digit 推入 rev 末尾
rev = rev * 10 + digit

//标准程序
        int res = 0;
        while(x!=0) {
            //每次取末尾数字
            int tmp = x%10;
            //判断是否 大于 最大32位整数
            if (res>214748364 || (res==214748364 && tmp>7)) {
                return 0;
            }
            //判断是否 小于 最小32位整数
            if (res<-214748364 || (res==-214748364 && tmp<-8)) {
                return 0;
            }
            res = res*10 + tmp;
            x /= 10;
        }
        return res;
```
衍生问题：如何给string类型指定固定长度?数值变量如何作为变量创建的初始参数使用？
1. string strabc(10, '\0')或拷贝给string一个目标长度的已知字符串;
2. 
   ```C
	// matrixSysten[n+1][n+2]的创建
   double **matrixSystem = new double*[n + 1];
   for (int i = 0; i < n + 1; i++)
        matrixSystem[i] = new double[n + 2];
   ```
3. vector/<"Type"/>


### 字符串转换整数

为了有条理地分析每个输入字符的处理方法，可以使用自动机(Finite State Machine)：
在每个时刻有一个状态s，每次从序列中输入一个字符c，并根据字符 c 转移到下一个状态s'。只需要建立一个覆盖所有情况的从s与c映射到s'的表格即可
{% asset_img S1.png %}

```C
if(s.length() == 0) return 0;
bool flag = false;//是否已经读取到数字字符，默认没有
int symbol = 1;//记录数字正负号，1位正好，0为负号
int res = 0;//结果
for(int i=0;i<s.length();i++){
    if(isdigit(s[i])){
        flag = true;
        if(res < 0){
            if(res < INT_MIN/10) return INT_MIN;
            if(48-s[i] <= INT_MIN-res*10) return INT_MIN;}
        else{
            if(res > INT_MAX/10) return INT_MAX;
            if(s[i]-48 >= INT_MAX-res*10) return INT_MAX;//s[i]-48=s[i]-'0'
        }
        if(symbol==0) res = res*10 - (s[i]-48);
        else res = res*10 + (s[i]-48);
        continue;
    }else if(!flag && s[i]=='-'){//没有读到数字字符且字符为负号
        symbol=0;
        flag = true;
        continue;
    }else if(!flag && s[i]=='+'){
        symbol=1;
        flag = true;
        continue;
    }else if(!flag && isspace(s[i])){
        continue;
    }else break;
}
return res; 
///////////////////DFS解法/////////////////////
INT_MAX = 2 ** 31 - 1
INT_MIN = -2 ** 31
class Automaton:
    def __init__(self):
        self.state = 'start'
        self.sign = 1
        self.ans = 0
        self.table = {
            'start': ['start', 'signed', 'in_number', 'end'],
            'signed': ['end', 'end', 'in_number', 'end'],
            'in_number': ['end', 'end', 'in_number', 'end'],
            'end': ['end', 'end', 'end', 'end'],
        }
        
    def get_col(self, c):
        if c.isspace():
            return 0
        if c == '+' or c == '-':
            return 1
        if c.isdigit():
            return 2
        return 3

    def get(self, c):
        self.state = self.table[self.state][self.get_col(c)]
        if self.state == 'in_number':
            self.ans = self.ans * 10 + int(c)
            self.ans = min(self.ans, INT_MAX) if self.sign == 1 else min(self.ans, -INT_MIN)
        elif self.state == 'signed':
            self.sign = 1 if c == '+' else -1

class Solution:
    def myAtoi(self, str: str) -> int:
        automaton = Automaton()
        for c in str:
            automaton.get(c)
        return automaton.sign * automaton.ans
```
stringstream能够自动解析定界符，例如空格，逗号等
```C
    stringstream liu(s);
    int n=0;
    liu>>n;
    return n;
```

### 回文数
思路1.反转整个int
如果回文后的整数溢出，说明此数非回文数，需要使用long int类型储存回文数并判断与INT_MAX的大小。
思路2.反转半个int
如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。可以不判断数长的奇偶性来反转。
例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
```C
 bool isPalindrome(int x) {
        // 如上所述，当 x < 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        return x == revertedNumber || x == revertedNumber / 10;
    }
```

### 正则表达式匹配
正则表达式应用：
1. 测试字符串内的模式。例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
2. 替换文本。可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
3. 基于模式匹配从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。


### 盛最多水的容器
双指针法：

### 整数转罗马数字


### 罗马数字转整数


### 最长公共前缀
```C
int minLength = min_element(strs.begin(), strs.end(), [](const string& s, const string& t) 
{return s.size() < t.size();})->size();
```
### 三数之和
双指针方法：
先让数组有序，也就是需要先对数组进行排序
然后每次固定一个元素，再去寻找另外两个元素，也就是双指针
```C
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({nums[first], nums[second], nums[third]});
                }
            }
        }
        return ans;
```

### 最接近的三数之和
双指针

### 电话号码的字母组合
出现所有组合的字眼时，一般用回溯算法（递归）
回溯三问：当前操作？子问题？下一个子问题？
```C
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';     // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index + 1);    // 递归，注意index+1，一下层要处理下一个数字了
            s.pop_back();                       // 回溯 
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
```

### 四数之和
双指针的基础上再进行剪枝

在确定第一个数之后，如果 $\textit{target}nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target$，说明此时剩下的三个数无论取什么值，四数之和一定大于 target\textit{target}target，因此退出第一重循环；
在确定第一个数之后，如果 $\textit{target}nums[i]+nums[n−3]+nums[n−2]+nums[n−1]<target$，说明此时剩下的三个数无论取什么值，四数之和一定小于 target，因此第一重循环直接进入下一轮，
在确定前两个数之后，如果 $\textit{target}nums[i]+nums[j]+nums[j+1]+nums[j+2]>target$，说明此时剩下的两个数无论取什么值，四数之和一定大于target，因此退出第二重循环；
在确定前两个数之后，如果$nums[i]+nums[j]+nums[n−2]+nums[n−1]<target$，说明此时剩下的两个数无论取什么值，四数之和一定小于target，因此第二重循环直接进入下一轮，


### 删除链表的倒数第 N 个结点
在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。
```C
class Solution {
public:
    int getLength(ListNode* head) {
        int length = 0;
        while (head) {
            ++length;
            head = head->next;
        }
        return length;
    }

    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // Listnode* dummy=malloc(sizeof(ListNode))
        // dummy->val=0;dummy->next=head;
        ListNode* dummy = new ListNode(0, head);
        int length = getLength(head);
        ListNode* cur = dummy;
        for (int i = 1; i < length - n + 1; ++i) {
            cur = cur->next;
        }
        cur->next = cur->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```
使用栈方法，一般适用于倒序方法
```C
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0, head);
        stack<ListNode*> stk;
        ListNode* cur = dummy;
        while (cur) {
            stk.push(cur);
            cur = cur->next;
        }
        for (int i = 0; i < n; ++i) {
            stk.pop();
        }
        ListNode* prev = stk.top();
        prev->next = prev->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```

### 有效的括号

### 合并两个有序链表